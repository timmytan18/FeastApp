diff --git a/node_modules/react-native-walkthrough-tooltip/src/tooltip.d.ts b/node_modules/react-native-walkthrough-tooltip/src/tooltip.d.ts
index 45aa31e..5a7ef59 100644
--- a/node_modules/react-native-walkthrough-tooltip/src/tooltip.d.ts
+++ b/node_modules/react-native-walkthrough-tooltip/src/tooltip.d.ts
@@ -44,6 +44,9 @@ declare module 'react-native-walkthrough-tooltip' {
 
     // Styles the View element that wraps the children to clone it
     childrenWrapperStyle?: StyleProp<ViewStyle>;
+
+    // Styles the view element that wraps the original children
+    parentWrapperStyle?: StyleProp<ViewStyle>
   }
 
   export interface TooltipProps extends Partial<TooltipStyleProps> {
diff --git a/node_modules/react-native-walkthrough-tooltip/src/tooltip.js b/node_modules/react-native-walkthrough-tooltip/src/tooltip.js
index 4de1852..e849c2b 100644
--- a/node_modules/react-native-walkthrough-tooltip/src/tooltip.js
+++ b/node_modules/react-native-walkthrough-tooltip/src/tooltip.js
@@ -110,10 +110,13 @@ class Tooltip extends Component {
   constructor(props) {
     super(props);
 
+    mounted = false;
+
     const { isVisible, useInteractionManager } = props;
 
     this.isMeasuringChild = false;
     this.interactionPromise = null;
+    this.dimensionsSubscription = null;
 
     this.childWrapper = React.createRef();
     this.state = {
@@ -137,7 +140,11 @@ class Tooltip extends Component {
   }
 
   componentDidMount() {
-    Dimensions.addEventListener('change', this.updateWindowDims);
+    this.mounted = true;
+    this.dimensionsSubscription = Dimensions.addEventListener(
+      'change',
+      this.updateWindowDims,
+    );
   }
 
   componentDidUpdate(prevProps, prevState) {
@@ -150,14 +157,25 @@ class Tooltip extends Component {
     const insetsChanged = !rfcIsEqual(prevState.displayInsets, displayInsets);
 
     if (contentChanged || placementChanged || becameVisible || insetsChanged) {
-      setTimeout(() => {
-        this.measureChildRect();
-      });
+      if (this.mounted) {
+        setTimeout(() => {
+          this.measureChildRect();
+        });
+      }
     }
   }
 
   componentWillUnmount() {
-    Dimensions.removeEventListener('change', this.updateWindowDims);
+    // removeEventListener deprecated
+    // https://reactnative.dev/docs/dimensions#removeeventlistener
+    if (this.dimensionsSubscription?.remove) {
+      // react native >= 0.65.*
+      this.dimensionsSubscription.remove();
+    } else {
+      // react native < 0.65.*
+      Dimensions.removeEventListener('change', this.updateWindowDims);
+    }
+    this.mounted = false;
     if (this.interactionPromise) {
       this.interactionPromise.cancel();
     }
@@ -196,22 +214,24 @@ class Tooltip extends Component {
   }
 
   updateWindowDims = dims => {
-    this.setState(
-      {
-        windowDims: dims.window,
-        contentSize: new Size(0, 0),
-        adjustedContentSize: new Size(0, 0),
-        anchorPoint: new Point(0, 0),
-        tooltipOrigin: new Point(0, 0),
-        childRect: new Rect(0, 0, 0, 0),
-        measurementsFinished: false,
-      },
-      () => {
-        setTimeout(() => {
-          this.measureChildRect();
-        }, 500); // give the rotation a moment to finish
-      },
-    );
+    if (this.mounted) {
+      this.setState(
+        {
+          windowDims: dims.window,
+          contentSize: new Size(0, 0),
+          adjustedContentSize: new Size(0, 0),
+          anchorPoint: new Point(0, 0),
+          tooltipOrigin: new Point(0, 0),
+          childRect: new Rect(0, 0, 0, 0),
+          measurementsFinished: false,
+        },
+        () => {
+          setTimeout(() => {
+            this.measureChildRect();
+          }, 500); // give the rotation a moment to finish
+        },
+      );
+    }
   };
 
   doChildlessPlacement = () => {
@@ -227,24 +247,28 @@ class Tooltip extends Component {
   measureContent = e => {
     const { width, height } = e.nativeEvent.layout;
     const contentSize = new Size(width, height);
-    this.setState({ contentSize }, () => {
-      this.computeGeometry();
-    });
+    if (this.mounted) {
+      this.setState({ contentSize }, () => {
+        this.computeGeometry();
+      });
+    }
   };
 
   onChildMeasurementComplete = rect => {
-    this.setState(
-      {
-        childRect: rect,
-        waitingForInteractions: false,
-      },
-      () => {
-        this.isMeasuringChild = false;
-        if (this.state.contentSize.width) {
-          this.computeGeometry();
-        }
-      },
-    );
+    if (this.mounted) {
+      this.setState(
+        {
+          childRect: rect,
+          waitingForInteractions: false,
+        },
+        () => {
+          this.isMeasuringChild = false;
+          if (this.state.contentSize.width) {
+            this.computeGeometry();
+          }
+        },
+      );
+    }
   };
 
   measureChildRect = () => {
@@ -334,13 +358,15 @@ class Tooltip extends Component {
 
     const { tooltipOrigin, anchorPoint, adjustedContentSize } = geom;
 
-    this.setState({
-      tooltipOrigin,
-      anchorPoint,
-      placement,
-      measurementsFinished: childRect.width && contentSize.width,
-      adjustedContentSize,
-    });
+    if (this.mounted) {
+      this.setState({
+        tooltipOrigin,
+        anchorPoint,
+        placement,
+        measurementsFinished: childRect.width && contentSize.width,
+        adjustedContentSize,
+      });
+    }
   };
 
   renderChildInTooltip = () => {
@@ -428,7 +454,12 @@ class Tooltip extends Component {
   };
 
   render() {
-    const { children, isVisible, useReactNativeModal, modalComponent } = this.props;
+    const {
+      children,
+      isVisible,
+      useReactNativeModal,
+      modalComponent,
+    } = this.props;
 
     const hasChildren = React.Children.count(children) > 0;
     const showTooltip = isVisible && !this.state.waitingForInteractions;
@@ -449,7 +480,11 @@ class Tooltip extends Component {
 
         {/* This renders the child element in place in the parent's layout */}
         {hasChildren ? (
-          <View ref={this.childWrapper} onLayout={this.measureChildRect}>
+          <View
+            ref={this.childWrapper}
+            onLayout={this.measureChildRect}
+            style={this.props.parentWrapperStyle}
+          >
             {children}
           </View>
         ) : null}
